[
    {
        "content": "<p>Well, this will be a list of weird things in the Nix store protocol for now and I'll decide on what to do to avoid them later</p>",
        "id": 480073432,
        "sender_full_name": "RGBCube",
        "timestamp": 1730475970
    },
    {
        "content": "<p>First off: no copying files into realizers. Only derivations.</p>\n<p>You know how when you do </p>\n<div class=\"codehilite\" data-code-language=\"Nix\"><pre><span></span><code><span class=\"nb\">derivation</span> <span class=\"p\">{</span>\n  <span class=\"ss\">builder</span> <span class=\"o\">=</span> <span class=\"l\">./builder</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Nix first</p>\n<ol>\n<li>Copies the file to the store</li>\n<li>Then it actually creates the the derivation files with that path referenced</li>\n</ol>\n<p>And how that file itself isn't actually a derivation? But instead is just a file?</p>",
        "id": 480076973,
        "sender_full_name": "RGBCube",
        "timestamp": 1730477164
    },
    {
        "content": "<p>We can avoid this by letting people specify paths inside derivations:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"o\">.</span><span class=\"n\">builder</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">executable</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">fileContent</span><span class=\"w\"> </span><span class=\"s\">\"binary contents of it here\"</span><span class=\"p\">;</span>\n\n<span class=\"w\">  </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"s\">\"builder\"</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">#</span><span class=\"w\"> </span><span class=\"n\">relative</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">pwd</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"kr\">default</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>These \"paths\" inside derivations will be an attribute of the derivation itself.</p>\n<p>Now, when the command is run, the process will see this filesystem layout:</p>\n<div class=\"codehilite\"><pre><span></span><code>/\n  var/lib/real/xxxxx-that-drv/ # this is our pwd\n    builder\n</code></pre></div>\n<p>But of course this is quite inefficient. Every time we change that derivation, we have to write another file with the exact same contents. How do we avoid this?</p>\n<p>By making a derivation with only that file, of course:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">\\</span><span class=\"n\">thatfileder</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">outputDirectory</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">builder</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">executable</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">fileContent</span><span class=\"w\"> </span><span class=\"s\">\"binary contents here\"</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"p\">};</span>\n<span class=\"p\">};</span>\n\n<span class=\"nf\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">pathOf</span><span class=\"w\"> </span><span class=\"n\">thatfileder</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"s\">\"/builder\"</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>This will also mandate that our derivation should not require a command, which is a good thing.</p>\n<p>This will be what things like <code>./foo.sh</code> and <code>./mydir</code> desugar to too. These two are equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"o\">.</span><span class=\"p\">`</span><span class=\"n\">foo</span><span class=\"o\">.</span><span class=\"n\">sh</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"o\">./</span><span class=\"n\">foo</span><span class=\"o\">.</span><span class=\"n\">sh</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"o\">.</span><span class=\"n\">mydir</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"o\">./</span><span class=\"n\">mydir</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"o\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">pathOf</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">paths</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">outputDirectory</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"o\">#</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">executable</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">automatically</span><span class=\"w\"> </span><span class=\"n\">determined</span>\n<span class=\"w\">      </span><span class=\"p\">`</span><span class=\"n\">foo</span><span class=\"o\">.</span><span class=\"n\">sh</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">executable</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">fileContents</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"s\">\"foo.sh\"</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n<span class=\"w\">  </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"s\">\"/foo.sh\"</span><span class=\"p\">;</span>\n\n<span class=\"w\">  </span><span class=\"n\">paths</span><span class=\"o\">.</span><span class=\"n\">mydir</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">pathOf</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">derive</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">paths</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">outputDirectory</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"n\">idk</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fileContents</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">readFile</span><span class=\"w\"> </span><span class=\"s\">\"aaa\"</span><span class=\"p\">;</span>\n<span class=\"w\">      </span><span class=\"o\">#</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"n\">derivations</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"o\">?</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n<span class=\"w\">  </span><span class=\"p\">});</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 480080891,
        "sender_full_name": "RGBCube",
        "timestamp": 1730478664
    },
    {
        "content": "<p>Notice how we don't need the concept of \"outputs\" where we magically get mutable store paths, as we can now specify output directories in the filesystem layout, right inside our derivation? These directories will persist even after the derivation builds. But we have another problem now:</p>\n<p>How do we make them content addressed and garbage collect them individually, without affecting the integrity? Luckily there is a smart way out.</p>\n<p>We now hash the derivation individually with separate views for every output directory, while replacing self references with a fixed magic hash, and move them to their respective <code>/var/lib/real/xxhashofthisoutput-llvm/</code> and finally replace the cross and self references with the respective hashes of the output derivations.</p>",
        "id": 480084683,
        "sender_full_name": "RGBCube",
        "timestamp": 1730480072
    },
    {
        "content": "<p>Though, as discussed earlier, this will require even more communication for clients to find out paths. I'll tackle this when I'm actually implementing it.</p>",
        "id": 480085836,
        "sender_full_name": "RGBCube",
        "timestamp": 1730480461
    },
    {
        "content": "<p>One thing this WILL break is binaries not using absolute references when cross referencing other outputs, but I'm sure nothing ever does that so it's fine.</p>\n<p>Or maybe we can fix this by symlinking the other output directories (of which are not the content addressed one) into every output derivation.</p>",
        "id": 480087377,
        "sender_full_name": "RGBCube",
        "timestamp": 1730481051
    }
]